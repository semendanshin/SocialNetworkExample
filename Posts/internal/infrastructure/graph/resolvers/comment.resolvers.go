package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.47

import (
	"Posts/internal/infrastructure/graph"
	"Posts/internal/infrastructure/graph/middleware"
	"Posts/internal/infrastructure/graph/model"
	"Posts/internal/utils/mappers"
	"context"
	"log/slog"
	"time"

	"github.com/google/uuid"
)

// Author is the resolver for the author field.
func (r *commentResolver) Author(ctx context.Context, obj *model.Comment) (*model.User, error) {
	user, err := middleware.GetUserLoader(ctx).Load(obj.AuthorID)
	if err != nil {
		return nil, err
	}

	return mappers.DomainToModelUser(user), nil
}

// Post is the resolver for the post field.
func (r *commentResolver) Post(ctx context.Context, obj *model.Comment) (*model.Post, error) {
	post, err := middleware.GetPostLoader(ctx).Load(obj.PostID)
	if err != nil {
		return nil, err

	}

	return mappers.DomainToModelPost(post), nil
}

// Parent is the resolver for the parent field.
func (r *commentResolver) Parent(ctx context.Context, obj *model.Comment) (*model.Comment, error) {
	if obj.ParentID == nil {
		return nil, nil
	}

	comment, err := middleware.GetCommentLoader(ctx).Load(*obj.ParentID)
	if err != nil {
		return nil, err
	}

	return mappers.DomainToModelComment(comment), nil
}

// Children is the resolver for the children field.
func (r *commentResolver) Children(ctx context.Context, obj *model.Comment, limit *int, offset *int) ([]*model.Comment, error) {
	comments, err := r.cuc.GetChildren(ctx, obj.ID, *limit, *offset)
	if err != nil {
		return nil, err
	}

	var modelComments []*model.Comment
	for _, comment := range comments {
		modelComments = append(modelComments, mappers.DomainToModelComment(comment))
	}

	return modelComments, nil
}

// CreateComment is the resolver for the createComment field.
func (r *mutationResolver) CreateComment(ctx context.Context, input model.NewComment) (*model.Comment, error) {
	comment := mappers.CreateDTOToDomainComment(&input)

	err := r.cuc.Create(ctx, comment)
	if err != nil {
		return nil, err
	}

	return mappers.DomainToModelComment(comment), nil
}

// Comment is the resolver for the comment field.
func (r *queryResolver) Comment(ctx context.Context, id uuid.UUID) (*model.Comment, error) {
	comment, err := r.cuc.GetByID(ctx, id)
	if err != nil {
		return nil, err
	}

	return mappers.DomainToModelComment(comment), nil
}

// Comments is the resolver for the comments field.
func (r *queryResolver) Comments(ctx context.Context, postID uuid.UUID, limit *int, offset *int) ([]*model.Comment, error) {
	comments, err := r.cuc.GetByPostID(ctx, postID, *limit, *offset)
	if err != nil {
		return nil, err
	}

	var modelComments []*model.Comment
	for _, comment := range comments {
		modelComments = append(modelComments, mappers.DomainToModelComment(comment))
	}

	return modelComments, nil
}

// CommentAdded is the resolver for the commentAdded field.
func (r *subscriptionResolver) CommentAdded(ctx context.Context, postID uuid.UUID, limit *int) (<-chan *model.Comment, error) {
	const op = "commentResolver.CommentAdded"

	commentChan := make(chan *model.Comment)
	ticker := time.NewTicker(1 * time.Second)
	lastSeen := time.Now()
	log := r.logger.With(slog.Any("operation", op))

	go func() {
		for {
			select {
			case <-ctx.Done():
				log.Debug("context done")
				ticker.Stop()
				close(commentChan)
				return
			case <-ticker.C:
				comment, err := r.cuc.GetLastComment(ctx, postID, lastSeen, *limit)
				if err != nil {
					log.Error("failed to get last comment", slog.Any("error", err.Error()))
					continue
				}

				log.Debug("got new comments", slog.Any("count", len(comment)))

				for _, comment := range comment {
					if comment.CreatedAt.After(lastSeen) {
						lastSeen = comment.CreatedAt
					}

					commentChan <- mappers.DomainToModelComment(comment)
				}
				log.Debug("sent new comments", slog.Any("count", len(comment)))
			}
		}
	}()

	return commentChan, nil
}

// Comment returns graph.CommentResolver implementation.
func (r *Resolver) Comment() graph.CommentResolver { return &commentResolver{r} }

type commentResolver struct{ *Resolver }
